name: Deploy to Argo CD on EKS
on:
 workflow_dispatch:

permissions:
      id-token: write   # This is required for requesting the JWT
      contents: write
      
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
  
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
         role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
         aws-region: ${{ secrets.REGION }}

    - name: Retrieve an EKS endpoint 
      run: |
        eks_endpoint=$(aws eks describe-cluster --name MyEKSCluster --query "cluster.endpoint" --output text)
        echo "EKS_Endpoint=$eks_endpoint" >> $GITHUB_ENV
        
    - name: Update an EKS endpoint in a yaml file and create a update script
      run: | 
        echo "sed -i 's|server: .*|server: $EKS_Endpoint|' my-app-argo-app.yaml" > update_script.sh

    - name: Get matching image tags 
      run: |
        output=$(aws ecr-public describe-images --repository-name my_repo_xgboost_test --region us-east-1)
        matching_images=$(echo "$output" | jq -r '.imageDetails[].imageTags[] | select(endswith("_xgboost"))')
        echo "IMAGE_TAG=$matching_images" >> $GITHUB_ENV
        
    - name: Update a docker image in a yaml file and update the update script
      run: | 
        echo "sed -i 's|value: .*|value: public.ecr.aws/v3z5t7a3/my_repo_xgboost_test:$IMAGE_TAG|' my-app-argo-app.yaml" >> update_script.sh

    - name: Print update script content
      run: |
        echo "Contents of update_script.sh:"
        cat update_script.sh
    
    - name: Get Bastion Host Public IP
      id: bastion_ip
      run: |
        bastion_ip=$(aws cloudformation describe-stacks --stack-name BastionHostStack --query "Stacks[0].Outputs[?OutputKey=='BastionPublicIP'].OutputValue" --output text)
        echo "::set-output name=ip::$bastion_ip"

    - name: Create SSH key file
      run: |
        echo "${{ secrets.SSH_KEY }}" > key.pem
        chmod 600 key.pem

    - name: SSH to Bastion host and load a yaml file 
      env:
         BASTION_IP: ${{ steps.bastion_ip.outputs.ip }}
      run: | 
        ssh -o StrictHostKeyChecking=no -i key.pem ec2-user@$BASTION_IP "
          if [ -f /home/ec2-user/my-app-argo-app.yaml ]; then
            echo 'File exists. Deleting...'
            rm /home/ec2-user/my-app-argo-app.yaml
          else
            echo 'File does not exist. Proceeding to download...'
          fi
          wget https://raw.githubusercontent.com/ruihukuang/Argo_Helm_Xgboost_EKS/main/my-app-argo-app.yaml
        "
        
    - name: SSH to Bastion Host and Update Kubeconfig
      env:
        BASTION_IP: ${{ steps.bastion_ip.outputs.ip }}
      run: |
        ssh -o StrictHostKeyChecking=no -i key.pem ec2-user@$BASTION_IP "
          if [ -f /home/ec2-user/update_script.sh ]; then
            echo 'update_script.sh exists. Deleting...'
            rm /home/ec2-user/update_script.sh
          else
            echo 'update_script.sh does not exist. Proceeding to copy...'
          fi"
        scp -o StrictHostKeyChecking=no -i key.pem update_script.sh ec2-user@$BASTION_IP:/home/ec2-user/
        ssh -o StrictHostKeyChecking=no -i key.pem ec2-user@$BASTION_IP << EOF
          set -ex  # Enable command tracing and exit on error
          aws eks update-kubeconfig --region ${{ secrets.REGION }} --name MyEKSCluster
          kubectl get nodes
          if ! kubectl get namespace argocd; then
            kubectl create namespace argocd
          else
            echo "Namespace argocd already exists"
          fi
          if ! kubectl get namespace my-app-test; then
            kubectl create namespace my-app-test
          else
            echo "Namespace my-app-test already exists"
          fi
          sudo chmod +x /home/ec2-user/update_script.sh
          sudo bash /home/ec2-user/update_script.sh
          echo "Contents of my-app-argo-app.yaml:"
          sudo cat /home/ec2-user/my-app-argo-app.yaml
          #Install Argo CLI
          sudo curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          sudo chmod +x /usr/local/bin/argocd
          # install helm 
          curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
          sudo chmod 700 get_helm.sh
          ./get_helm.sh
          #Add the Argo CD Helm Repository
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          #Install Argo CD Using Helm
          helm uninstall argocd --namespace argocd
          helm install argocd argo/argo-cd --namespace argocd --create-namespace
          # Wait for argocd-server to be deployed     
          # expose Argo CD API Server via an AWS Load Balancer, modify the argocd-server service.
          # Get the Load Balancer of Argo CD API Server URL
          # Access the Argo CD UI and get the password  
          # Log into Argo with an originial password
          # Update password in Argo CD
          # Log into Argo with a new password 
          # retrieve the name of the current Kubernetes context
          # Add a cluster into argo
          # Apply Argo CD Application
          # Install metrics-server
          # Show metrics
          kubectl get deployment argocd-server -n argocd -o jsonpath='{.status.readyReplicas}' | grep -q '1' && \
          kubectl patch svc argocd-server -n argocd --type='merge' -p '{"spec": {"type": "LoadBalancer"}}' && \
          Argo_URL=\$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}') && \
          Argo_OriginPW=\$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d) && \
          argocd login \$Argo_URL --username admin --password \$Argo_OriginPW --insecure && \
          argocd account update-password --current-password $Argo_OriginPW --new-password ${{ secrets.ARGOCD_NEW_PASSWORD }} && \
          argocd login $Argo_URL --username admin --password ${{ secrets.ARGOCD_NEW_PASSWORD }} && \
          ContextName=$(kubectl config current-context) && \
          argocd cluster add $ContextName --yes && \
          kubectl apply -f /home/ec2-user/my-app-argo-app.yaml && \
          kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml && \
          kubectl get deployment metrics-server -n kube-system -o jsonpath='{.status.readyReplicas}' | grep -q '1' && \
          kubectl top nodes && \
          kubectl top pods --all-namespaces 
        EOF
# kubectl get svc nginx-service -n my-app-test -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' URL of load balancer for nginx
